Operating Systems Lab
Assignment 4 Design Doc
By Group 4

Graph:
	The average number of nodes in graph given = 289003 / 37700 ~= 8
	
	It isn't efficient to store an adjacency matrix for it. So the graph in stored as an adjacency list.
	
	`vector::shrink_to_fit()` has been called after loading the graph to get rid of extra unused memory.

Node:
	Since the average degree is not high, it's not efficient to store priority for all other nodes. So for when `feedQueue` is to be sorted by no. of common nodes, we simply calculated the respective priority at runtime.

	`vector<Nodes>` is the list of all nodes. It is used to quickly reference any node, without accessing the graph everytime.

	Each node stores a `wallQueue`, a `feedQueue`, a counter of `past_action`s, a pointer to its list of `neighbours`, and `mutex` for `feedQueue`.

Action:
	Nothing special. Simply stores `action_id`, `user_id` of the user who generated the action, `type` of action, `timestamp` of action generation

Queue:
	A special multi-queue data structure created by us to streamline the efficiency of the threads.

	Contains N `std::queue`s, a `mutex` and a `conditional variable` for each, a counter, a `mutex` for pushing to the queue.

	Workflow:
		Push:
			Elements are pushed in a round robin manner to the queue. Counter is incremented to check to which queue the element should be inserted. `push_mutex` guards the counter. `mutexes[index]` guards the queue where insertion happens. The `conditional[index]` is signalled after an insertion happens.
		
		Pop:
			Pop takes an argument to specify which queue to pop from. Again the queue is guarded by `mutexes[index]`, and is waited for at `conditional[index]`.

sns.cpp (Main Thread):
	1. Reads and loads the graph to memory. Every adjacency list is sorted since `std::set_intersection()` needs to be called later for assigning priority in `feedQueue` of `Node`s.
	2. Spawns 36 threads (1 for `userSimulator`, 25 for `pushUpdate`, 10 for `readPost`).

userSimulator.cpp (User Simulator Thread):
	Wakes up every 120s and generates random `Action`s proportional to the `Node`'s degree for 100 random `Node`s, pushing every of them to `shared_queue`.

pushUpdate.cpp (Push Update Thread):
	Pops from `shared_queue` the next `Action` to handle and 
		1. Updates `feedQueue` of all `Node`s who are the neighbours of the `Node` which generated the action.
		2. Pushes the affected nodes to `updates`. (Note a `Node` maybe pushed into `updates` multiple times. This is not an issue as explained later.)

readPost.cpp (Read Post Thread):
	
